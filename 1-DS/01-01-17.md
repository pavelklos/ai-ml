# Datové typy a konverze v datové vědě

Tento notebook zkoumá různé datové typy v Pythonu, NumPy a Pandas, společně s technikami konverze, které jsou zásadní pro pracovní postupy v datové vědě. Podíváme se na efektivní práci s různými datovými typy, jejich vzájemné konverze a optimalizaci využití paměti.

## 1. Potřebné knihovny

```python
# Import základních knihoven
import sys
import math
import datetime

# Import knihoven pro datovou vědu
import numpy as np
import pandas as pd

# Import nástrojů pro analýzu paměti
from sys import getsizeof
import matplotlib.pyplot as plt

# Výpis verzí pro reprodukovatelnost
print(f"Python version: {sys.version}")
print(f"NumPy version: {np.__version__}")
print(f"Pandas version: {pd.__version__}")
```

## 2. Datové typy v Pythonu

Python obsahuje několik vestavěných datových typů, které tvoří základ pro operace v datové vědě:

### 2.1 Číselné typy: int, float

```python
# Příklady celých čísel
x = 42
y = 1000000000000  # Celá čísla v Pythonu mají libovolnou přesnost

# Příklady desetinných čísel
a = 3.14159
b = 2.71828
c = 1.0e-10  # Vědecká notace

# Výpis typů a hodnot
print(f"x = {x}, type: {type(x)}")
print(f"y = {y}, type: {type(y)}")
print(f"a = {a}, type: {type(a)}")
print(f"b = {b}, type: {type(b)}")
print(f"c = {c}, type: {type(c)}")

# Číselné operace
print(f"\nOperace:")
print(f"x + a = {x + a}, type: {type(x + a)}")  # Poznámka: int + float = float
print(f"a / x = {a / x}, type: {type(a / x)}")
print(f"x // 5 = {x // 5}, type: {type(x // 5)}")  # Celočíselné dělení
print(f"x % 5 = {x % 5}, type: {type(x % 5)}")  # Modulo
```

### 2.2 Logický typ: bool

```python
# Příklady logických hodnot
t = True
f = False

# Logické hodnoty z porovnání
is_greater = x > a
is_equal = 10 == 10.0  # True, i když jsou typy rozdílné

print(f"t = {t}, type: {type(t)}")
print(f"f = {f}, type: {type(f)}")
print(f"{x} > {a} = {is_greater}, type: {type(is_greater)}")
print(f"10 == 10.0: {is_equal}, type: {type(is_equal)}")

# Číselné hodnoty logických typů (používané v kalkulacích)
print(f"\nLogické hodnoty jako čísla:")
print(f"True + True = {True + True}")
print(f"int(True) = {int(True)}")
print(f"int(False) = {int(False)}")

# Logické operace
print(f"\nLogické operace:")
print(f"True and False = {True and False}")
print(f"True or False = {True or False}")
print(f"not True = {not True}")
```

### 2.3 Textový typ: str

```python
# Příklady řetězců
s1 = "Hello, World!"
s2 = 'Data Science'
s3 = """Multi-line
string example"""

print(f"s1 = {s1}, type: {type(s1)}")
print(f"s2 = {s2}, type: {type(s2)}")
print(f"s3 = {s3}, type: {type(s3)}")

# Operace s řetězci
print(f"\nOperace s řetězci:")
print(f"Délka s1: {len(s1)}")
print(f"s1 velká písmena: {s1.upper()}")
print(f"s2 malá písmena: {s2.lower()}")
print(f"Rozdělení s1: {s1.split(',')}")
print(f"Spojení řetězců: {'_'.join(['a', 'b', 'c'])}")
print(f"Nahrazení v s1: {s1.replace('Hello', 'Hi')}")

# Formátování řetězců
name = "Python"
version = 3.9
print(f"String formatting: {name} version {version}")
print("Old-style formatting: %s version %.1f" % (name, version))
print("Format method: {} version {}".format(name, version))
```

### 2.4 Kontejnerové typy: list, tuple, dict, set

```python
# Seznam - měnitelná uspořádaná kolekce
my_list = [1, 2, 3, 'a', 'b', True]
print(f"my_list = {my_list}, type: {type(my_list)}")
print(f"První prvek: {my_list[0]}")
my_list[0] = 100  # Seznamy jsou měnitelné
print(f"Po úpravě: {my_list}")
print(f"Část seznamu: {my_list[2:5]}")

# N-tice - neměnná uspořádaná kolekce
my_tuple = (1, 2, 3, 'a', 'b', True)
print(f"\nmy_tuple = {my_tuple}, type: {type(my_tuple)}")
print(f"Druhý prvek: {my_tuple[1]}")
# my_tuple[0] = 100  # Toto by vyvolalo chybu, protože n-tice jsou neměnné

# Slovník - páry klíč-hodnota
my_dict = {'name': 'John', 'age': 30, 'city': 'New York'}
print(f"\nmy_dict = {my_dict}, type: {type(my_dict)}")
print(f"Přístup podle klíče: my_dict['name'] = {my_dict['name']}")
my_dict['age'] = 31  # Úprava hodnoty
my_dict['country'] = 'USA'  # Přidání nového páru klíč-hodnota
print(f"Po úpravě: {my_dict}")
print(f"Klíče: {list(my_dict.keys())}")
print(f"Hodnoty: {list(my_dict.values())}")
print(f"Položky: {list(my_dict.items())}")

# Množina - neuspořádaná kolekce jedinečných prvků
my_set = {1, 2, 3, 2, 1, 3, 4, 5}  # Duplicity jsou automaticky odstraněny
print(f"\nmy_set = {my_set}, type: {type(my_set)}")
my_set.add(6)
print(f"Po přidání 6: {my_set}")
my_set.remove(3)
print(f"Po odstranění 3: {my_set}")

# Operace s množinami
set_a = {1, 2, 3, 4}
set_b = {3, 4, 5, 6}
print(f"\nOperace s množinami:")
print(f"set_a = {set_a}, set_b = {set_b}")
print(f"Sjednocení: {set_a | set_b}")
print(f"Průnik: {set_a & set_b}")
print(f"Rozdíl (set_a - set_b): {set_a - set_b}")
print(f"Symetrická diference: {set_a ^ set_b}")
```

## 3. Datové typy v NumPy

NumPy zavádí rozsáhlejší sadu datových typů, které jsou efektivnější z hlediska paměti a lépe přizpůsobené pro vědecké výpočty:

```python
# Vytvoření polí s různými datovými typy
np_int8 = np.array([1, 2, 3], dtype=np.int8)
np_int32 = np.array([1, 2, 3], dtype=np.int32)
np_int64 = np.array([1, 2, 3], dtype=np.int64)
np_float32 = np.array([1.0, 2.0, 3.0], dtype=np.float32)
np_float64 = np.array([1.0, 2.0, 3.0], dtype=np.float64)
np_bool = np.array([True, False, True], dtype=np.bool_)

# Výpis datových typů a využití paměti
print(f"NumPy int8 array: {np_int8}, dtype: {np_int8.dtype}, itemsize: {np_int8.itemsize} bytes")
print(f"NumPy int32 array: {np_int32}, dtype: {np_int32.dtype}, itemsize: {np_int32.itemsize} bytes")
print(f"NumPy int64 array: {np_int64}, dtype: {np_int64.dtype}, itemsize: {np_int64.itemsize} bytes")
print(f"NumPy float32 array: {np_float32}, dtype: {np_float32.dtype}, itemsize: {np_float32.itemsize} bytes")
print(f"NumPy float64 array: {np_float64}, dtype: {np_float64.dtype}, itemsize: {np_float64.itemsize} bytes")
print(f"NumPy bool array: {np_bool}, dtype: {np_bool.dtype}, itemsize: {np_bool.itemsize} bytes")

# Rozsahy datových typů
print(f"\nRozsahy datových typů NumPy:")
print(f"np.int8 rozsah: {np.iinfo(np.int8).min} to {np.iinfo(np.int8).max}")
print(f"np.uint8 rozsah: {np.iinfo(np.uint8).min} to {np.iinfo(np.uint8).max}")
print(f"np.int32 rozsah: {np.iinfo(np.int32).min} to {np.iinfo(np.int32).max}")
print(f"np.int64 rozsah: {np.iinfo(np.int64).min} to {np.iinfo(np.int64).max}")
print(f"np.float32 rozsah: {np.finfo(np.float32).min} to {np.finfo(np.float32).max}")
print(f"np.float32 přesnost: {np.finfo(np.float32).precision} číslic")
print(f"np.float64 rozsah: {np.finfo(np.float64).min} to {np.finfo(np.float64).max}")
print(f"np.float64 přesnost: {np.finfo(np.float64).precision} číslic")
```

### 3.1 Speciální datové typy NumPy

```python
# Komplexní čísla
complex_array = np.array([1+2j, 3+4j, 5+6j], dtype=np.complex128)
print(f"Komplexní pole: {complex_array}, dtype: {complex_array.dtype}")
print(f"Reálná část: {complex_array.real}")
print(f"Imaginární část: {complex_array.imag}")

# Textové datové typy v NumPy
str_array = np.array(['apple', 'banana', 'cherry'], dtype=np.bytes_)
unicode_array = np.array(['apple', 'banana', 'cherry'], dtype=np.str_)
print(f"\nŘetězcové pole: {str_array}, dtype: {str_array.dtype}")
print(f"Unicode pole: {unicode_array}, dtype: {unicode_array.dtype}")

# Datumové datové typy
dates = np.array(['2021-01-01', '2021-01-15', '2021-02-01'], dtype='datetime64')
print(f"\nPole s datumy: {dates}, dtype: {dates.dtype}")
print(f"Rozdíl mezi daty: {dates[1] - dates[0]}")

# Strukturovaná pole (podobná záznamům/strukturám v jiných jazycích)
person_type = np.dtype([('name', 'U10'), ('age', 'i4'), ('weight', 'f4')])
people = np.array([('Alice', 25, 55.0), ('Bob', 30, 85.5), ('Charlie', 35, 68.0)], dtype=person_type)
print(f"\nStrukturované pole:")
print(people)
print(f"Jména: {people['name']}")
print(f"Věk: {people['age']}")
print(f"Průměrná váha: {np.mean(people['weight'])}")
```

## 4. Datové typy v Pandas

Pandas rozšiřuje datové typy Pythonu a NumPy pro efektivní zpracování tabulkových a časových dat:

```python
# Vytvoření DataFrame s různými datovými typy
data = {
    'integer_col': [1, 2, 3, 4, 5],
    'float_col': [1.1, 2.2, 3.3, 4.4, 5.5],
    'string_col': ['a', 'b', 'c', 'd', 'e'],
    'bool_col': [True, False, True, False, True],
    'datetime_col': pd.date_range('2021-01-01', periods=5),
    'category_col': pd.Categorical(['small', 'medium', 'large', 'small', 'medium']),
    'object_col': [{'a': 1}, [1, 2], (3, 4), {5, 6}, 'text']
}

df = pd.DataFrame(data)

# Zobrazení DataFrame a datových typů
print(df)
print("\nDatové typy ve DataFrame:")
print(df.dtypes)

# Metoda info poskytuje shrnutí datových typů a využití paměti
print("\nInformace o DataFrame:")
df.info()

# Detailní prozkoumání vybraných sloupců
print("\nDetailní průzkum sloupců:")
for col in ['integer_col', 'float_col', 'datetime_col', 'category_col']:
    print(f"\nSloupec: {col}")
    print(f"Typ: {type(df[col])}")
    print(f"Pandas dtype: {df[col].dtype}")
    print(f"Typ vzorové hodnoty: {type(df[col].iloc[0])}")
```

### 4.1 Specifické datové typy Pandas

```python
# Kategorický datový typ
# Užitečné pro sloupce s omezenou sadou možných hodnot
color_series = pd.Series(['red', 'green', 'blue', 'red', 'blue', 'red', 'green'])
color_cat = color_series.astype('category')

print(f"Původní série: {color_series.dtype}")
print(f"Kategorická série: {color_cat.dtype}")
print(f"Kategorie: {color_cat.cat.categories}")
print(f"Kódy: {color_cat.cat.codes}")
print(f"Využití paměti původní: {color_series.memory_usage(deep=True)} bajtů")
print(f"Využití paměti kategorické: {color_cat.memory_usage(deep=True)} bajtů")

# Nullable (pandas rozšíření) datové typy
# Poskytují konzistentnější zpracování chybějících hodnot
df_nullable = pd.DataFrame({
    'Int64': pd.Series([1, 2, None, 4], dtype='Int64'),
    'Float64': pd.Series([1.1, 2.2, None, 4.4], dtype='Float64'),
    'boolean': pd.Series([True, False, None, True], dtype='boolean'),
    'string': pd.Series(['a', 'b', None, 'd'], dtype='string')
})

print("\nDataFrame s nullable/rozšířenými typy:")
print(df_nullable)
print(df_nullable.dtypes)

# Datumové a časové datové typy
date_series = pd.Series(pd.date_range('2021-01-01', periods=5))
time_series = pd.Series(pd.date_range('00:00:00', periods=5, freq='h'))
timedelta_series = pd.Series([pd.Timedelta(days=1), 
                              pd.Timedelta(hours=2), 
                              pd.Timedelta(minutes=3)])

print("\nSérie s datumy:")
print(date_series)
print(f"dtype: {date_series.dtype}")

print("\nČasová série:")
print(time_series)
print(f"dtype: {time_series.dtype}")

print("\nTimedelta série:")
print(timedelta_series)
print(f"dtype: {timedelta_series.dtype}")
```

## 5. Kontrola a identifikace datových typů

```python
# Vestavěná kontrola typů v Pythonu
values = [42, 3.14, "hello", True, [1, 2, 3], {'a': 1}, (1, 2), {1, 2, 3}]

print("Vestavěná kontrola typů v Pythonu:")
for val in values:
    print(f"Hodnota: {val}, Typ: {type(val)}")

# Použití isinstance() pro kontrolu typů
print("\nKontrola typů s isinstance():")
print(f"42 je celé číslo: {isinstance(42, int)}")
print(f"3.14 je desetinné číslo: {isinstance(3.14, float)}")
print(f"3.14 je číslo: {isinstance(3.14, (int, float))}")  # Kontrola proti více typům
print(f"'hello' je řetězec: {isinstance('hello', str)}")
print(f"[1, 2, 3] je seznam: {isinstance([1, 2, 3], list)}")

# Kontrola typů NumPy
numpy_values = [
    np.array([1, 2, 3]),
    np.array([1.1, 2.2, 3.3]),
    np.array(['a', 'b', 'c']),
    np.array([True, False, True])
]

print("\nKontrola typů NumPy:")
for arr in numpy_values:
    print(f"Pole: {arr}, dtype: {arr.dtype}")
    print(f"  Je celé číslo: {np.issubdtype(arr.dtype, np.integer)}")
    print(f"  Je desetinné číslo: {np.issubdtype(arr.dtype, np.floating)}")
    print(f"  Je řetězec: {np.issubdtype(arr.dtype, np.character)}")
    print(f"  Je logická hodnota: {np.issubdtype(arr.dtype, np.bool_)}")

# Kontrola typů Pandas
print("\nKontrola typů Pandas:")
for col in df.columns:
    series = df[col]
    print(f"Sloupec: {col}, dtype: {series.dtype}")
    print(f"  Je číselný: {pd.api.types.is_numeric_dtype(series)}")
    print(f"  Je celočíselný: {pd.api.types.is_integer_dtype(series)}")
    print(f"  Je desetinný: {pd.api.types.is_float_dtype(series)}")
    print(f"  Je řetězec: {pd.api.types.is_string_dtype(series)}")
    print(f"  Je logický: {pd.api.types.is_bool_dtype(series)}")
    print(f"  Je kategorický: {isinstance(series.dtype, pd.CategoricalDtype)}")
    print(f"  Je datum: {pd.api.types.is_datetime64_any_dtype(series)}")
    print(f"  Je objekt: {pd.api.types.is_object_dtype(series)}")
```

## 6. Konverze typů v Pythonu

```python
# Explicitní konverze mezi číselnými typy
num_int = 123
num_float = 123.45
num_str = "456"
num_bool = True

print("Číselné konverze:")
print(f"int na float: {float(num_int)}, typ: {type(float(num_int))}")
print(f"float na int: {int(num_float)}, typ: {type(int(num_float))}")  # Ořezává, nezaokrouhluje
print(f"str na int: {int(num_str)}, typ: {type(int(num_str))}")
print(f"str na float: {float(num_str)}, typ: {type(float(num_str))}")
print(f"bool na int: {int(num_bool)}, typ: {type(int(num_bool))}")
print(f"int na bool: {bool(num_int)}, typ: {type(bool(num_int))}")  # 0 je False, jakékoli jiné číslo je True
print(f"Nula na bool: {bool(0)}, typ: {type(bool(0))}")

# Konverze řetězců
value_int = 123
value_float = 123.45
value_bool = False
value_list = [1, 2, 3]
value_tuple = (4, 5, 6)
value_dict = {'a': 1, 'b': 2}
value_set = {7, 8, 9}

print("\nŘetězcové konverze:")
print(f"int na str: {str(value_int)}, typ: {type(str(value_int))}")
print(f"float na str: {str(value_float)}, typ: {type(str(value_float))}")
print(f"bool na str: {str(value_bool)}, typ: {type(str(value_bool))}")
print(f"list na str: {str(value_list)}, typ: {type(str(value_list))}")
print(f"tuple na str: {str(value_tuple)}, typ: {type(str(value_tuple))}")
print(f"dict na str: {str(value_dict)}, typ: {type(str(value_dict))}")
print(f"set na str: {str(value_set)}, typ: {type(str(value_set))}")

# Konverze kontejnerových typů
sample_str = "hello"
sample_list = [1, 2, 3, 2, 1]
sample_tuple = (4, 5, 6, 5, 4)
sample_dict = {'a': 1, 'b': 2, 'c': 3}
sample_set = {7, 8, 9}

print("\nKonverze kontejnerových typů:")
print(f"str na list: {list(sample_str)}, typ: {type(list(sample_str))}")
print(f"list na tuple: {tuple(sample_list)}, typ: {type(tuple(sample_list))}")
print(f"tuple na list: {list(sample_tuple)}, typ: {type(list(sample_tuple))}")
print(f"list na set (odstraní duplicity): {set(sample_list)}, typ: {type(set(sample_list))}")
print(f"dict na list (získá klíče): {list(sample_dict)}, typ: {type(list(sample_dict))}")
print(f"dict na set (získá klíče): {set(sample_dict)}, typ: {type(set(sample_dict))}")
print(f"dict items na list: {list(sample_dict.items())}, typ: {type(list(sample_dict.items()))}")

# Vytvoření slovníku ze sekvencí
keys = ['name', 'age', 'city']
values = ['Alice', 30, 'New York']
print("\nVytvoření dict ze sekvencí:")
print(f"Použití zip: {dict(zip(keys, values))}")
print(f"Použití list comprehension: {dict([(keys[i], values[i]) for i in range(len(keys))])}")
```

### 6.1 Implicitní konverze typů

```python
# Implicitní konverze typů v Pythonu
print("Implicitní konverze typů:")
print(f"int + float: {10 + 3.5}, typ: {type(10 + 3.5)}")  # int je implicitně konvertován na float
print(f"int * bool: {10 * True}, typ: {type(10 * True)}")  # bool je implicitně konvertován na int
print(f"str + str: {'hello' + ' world'}, typ: {type('hello' + ' world')}")

# Python neprovádí implicitní konverzi v mnoha případech
try:
    result = "5" + 10  # Toto vyvolá TypeError
except TypeError as e:
    print(f"\nChyba při míchání nekompatibilních typů: {e}")

# Běžné vzory pro bezpečnou konverzi
value = "5"
number = 10
print(f"\nBezpečné konverze:")
print(f"str + int (bezpečné): {value + str(number)}")
print(f"str na int + int: {int(value) + number}")

# Konverze na číselné hodnoty s ošetřením chyb
strings = ["123", "123.45", "hello", "42x", ""]

print("\nBezpečná číselná konverze s ošetřením chyb:")
for s in strings:
    try:
        int_value = int(s)
        print(f"'{s}' převedeno na int: {int_value}")
    except ValueError:
        try:
            float_value = float(s)
            print(f"'{s}' převedeno na float: {float_value}")
        except ValueError:
            print(f"'{s}' nelze převést na číselný typ")

# Použití metod řetězce pro kontrolu před konverzí
print("\nValidace před konverzí:")
for s in strings:
    if s.isdigit():
        print(f"'{s}' je platný řetězec celého čísla")
    elif s.replace(".", "", 1).isdigit() and s.count(".") <= 1:
        print(f"'{s}' je platný řetězec desetinného čísla")
    else:
        print(f"'{s}' není platný číselný řetězec")
```

## 7. Konverze typů v NumPy

```python
# Vytvoření pole NumPy
arr_float = np.array([1.1, 2.2, 3.3, 4.4, 5.5])
print(f"Původní pole: {arr_float}, dtype: {arr_float.dtype}")

# Konverze na různé typy pomocí astype()
arr_int = arr_float.astype(np.int32)
arr_str = arr_float.astype(np.bytes_)
arr_bool = arr_float.astype(np.bool_)

print("Konverze:")
print(f"Na int32: {arr_int}, dtype: {arr_int.dtype}")  # Poznámka: ořezává desetinné části
print(f"Na řetězec: {arr_str}, dtype: {arr_str.dtype}")
print(f"Na logický: {arr_bool}, dtype: {arr_bool.dtype}")  # Nenulové hodnoty se stanou True

# Konverze datových typů s potenciální ztrátou dat
arr_large = np.array([300, 400, 500], dtype=np.int16)  # int16 max je 32767
try:
    arr_small = arr_large.astype(np.int8)  # int8 max je 127
    print(f"\nKonverze s přetečením: {arr_small}")  # Dojde k přetečení
except Exception as e:
    print(f"Chyba během konverze: {e}")

# Konverze mezi znaménkovými a bezznaménkovými typy
arr_signed = np.array([-5, 0, 5], dtype=np.int8)
arr_unsigned = arr_signed.astype(np.uint8)
print(f"\nZnaménkové pole: {arr_signed}, dtype: {arr_signed.dtype}")
print(f"Bezznaménkové pole: {arr_unsigned}, dtype: {arr_unsigned.dtype}")  # Záporné hodnoty přetečou

# Ztráta přesnosti při konverzi desetinných čísel
arr_double = np.array([1.123456789, 2.123456789], dtype=np.float64)
arr_single = arr_double.astype(np.float32)
arr_back = arr_single.astype(np.float64)  # Návrat zpět neobnoví přesnost

print(f"\nDouble precision: {arr_double}, dtype: {arr_double.dtype}")
print(f"Single precision: {arr_single}, dtype: {arr_single.dtype}")
print(f"Zpět na double: {arr_back}, dtype: {arr_back.dtype}")
print(f"Původní vs. převedené zpět (rovnost): {np.array_equal(arr_double, arr_back)}")

# Vytváření polí se smíšenými typy
mixed_list = [1, 2.5, "3", True]
arr_mixed = np.array(mixed_list)  # Převede se na řetězec (object dtype)
print(f"\nSeznam smíšených typů na pole: {arr_mixed}, dtype: {arr_mixed.dtype}")

# Více způsobů konverze typů
arr = np.array([1.5, 2.5, 3.5])
print(f"\nPůvodní: {arr}, dtype: {arr.dtype}")
print(f"Použití astype(): {arr.astype(int)}, dtype: {arr.astype(int).dtype}")
print(f"Použití konstruktoru array: {np.array(arr, dtype=int)}, dtype: {np.array(arr, dtype=int).dtype}")
print(f"Použití parametru dtype: {np.int32(arr)}, dtype: {np.int32(arr).dtype}")
```

### 7.1 Konverzní funkce NumPy

```python
# Další funkce NumPy pro konverzi typů
arr = np.array([1.5, 2.6, 3.7, 4.8, 5.9])

print("Konverzní funkce NumPy:")
print(f"np.floor(): {np.floor(arr)}, dtype: {np.floor(arr).dtype}")  # Zaokrouhlení dolů na nejbližší celé číslo
print(f"np.ceil(): {np.ceil(arr)}, dtype: {np.ceil(arr).dtype}")  # Zaokrouhlení nahoru na nejbližší celé číslo
print(f"np.round(): {np.round(arr)}, dtype: {np.round(arr).dtype}")  # Zaokrouhlení na nejbližší celé číslo
print(f"np.trunc(): {np.trunc(arr)}, dtype: {np.trunc(arr).dtype}")  # Oříznutí desetinné části

# Konverze z řetězců na čísla
str_arr = np.array(['1.5', '2.5', '3.5'])
print(f"\nŘetězcové pole: {str_arr}, dtype: {str_arr.dtype}")
print(f"Převedeno na float: {str_arr.astype(float)}, dtype: {str_arr.astype(float).dtype}")

# Vytvoření strukturovaného pole a extrakce polí s různými typy
structured = np.array([('Alice', 25, 55.0), ('Bob', 30, 85.5)], 
                      dtype=[('name', 'U10'), ('age', 'i4'), ('weight', 'f4')])
print(f"\nStrukturované pole:\n{structured}")
print(f"Pole jmen: {structured['name']}, dtype: {structured['name'].dtype}")
print(f"Pole věků: {structured['age']}, dtype: {structured['age'].dtype}")
print(f"Pole hmotností: {structured['weight']}, dtype: {structured['weight'].dtype}")

# View casting - reinterpretace bitů jako jiný typ bez kopírování
uint8_arr = np.array([72, 101, 108, 108, 111], dtype=np.uint8)  # ASCII pro "Hello"
print(f"\nUint8 pole (ASCII kódy): {uint8_arr}")
char_arr = uint8_arr.view('S1')  # Zobrazení jako 1-bajtové znaky
print(f"Jako znaky: {char_arr}")
back_to_uint8 = char_arr.view(np.uint8)  # Zobrazení zpět jako uint8
print(f"Zpět na uint8: {back_to_uint8}")
```

## 8. Konverze typů v Pandas

```python
# Vytvoření ukázkového DataFrame se smíšenými datovými typy
data = {
    'A': ['1', '2', '3', '4', '5'],                   # řetězce
    'B': [1.1, 2.2, 3.3, 4.4, 5.5],                   # desetinná čísla
    'C': ['True', 'False', 'True', 'False', 'True'],  # řetězcové logické hodnoty
    'D': ['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05'],  # řetězce datumů
    'E': ['a', 'b', 'c', 'd', 'e']                    # kategorie
}

df = pd.DataFrame(data)
print("Původní DataFrame s odvozenými typy:")
print(df.dtypes)

# Základní konverze typů s astype()
df['A_int'] = df['A'].astype(int)
df['A_float'] = df['A'].astype(float)
df['B_int'] = df['B'].astype(int)
df['C_bool'] = df['C'].astype(bool)  # Toto nebude fungovat správně s řetězci 'True'/'False'
df['E_cat'] = df['E'].astype('category')

print("\nPo základních konverzích typů:")
print(df.dtypes)
print(df)

# Správné převedení řetězcových logických hodnot
df['C_bool_correct'] = df['C'].map({'True': True, 'False': False})

# Převádění datumových řetězců na datetime pomocí to_datetime
df['D_datetime'] = pd.to_datetime(df['D'])

print("\nPo pokročilých konverzích typů:")
print(df.dtypes)
print(df[['C', 'C_bool', 'C_bool_correct', 'D', 'D_datetime']])
```

### 8.1 Konverzní funkce v Pandas

```python
# Vytvoření DataFrame s různorodými daty ke konverzi
data = {
    'int_col': ['1', '2', '3', '4', '5'],
    'float_col': ['1.1', '2.2', '3.3', '4.4', '5.5'],
    'mixed_numeric': ['1', '2.2', '3', '4.4', '5'],
    'bool_col': ['True', 'False', 'YES', 'no', '1'],
    'date_col': ['2021-01-01', '01/02/2021', '2021-03-01', '04/01/21', '2021-05-01'],
    'categorical': ['small', 'medium', 'large', 'medium', 'small']
}

df = pd.DataFrame(data)
print("Původní DataFrame:")
print(df.dtypes)  # Všechny sloupce jsou typu object (řetězec)
print(df)

# Použití specializovaných konverzních funkcí Pandas
print("\n1. Použití pd.to_numeric():")
# Převod na číselné typy s ošetřením chyb
for col in ['int_col', 'float_col', 'mixed_numeric']:
    # Různé možnosti zpracování chyb:
    # - 'error': výchozí, vyvolá výjimku při nemožnosti konvertovat
    # - 'coerce': převede chyby na NaN
    # - 'ignore': ponechá chyby beze změny
    df[f"{col}_num"] = pd.to_numeric(df[col], errors='coerce')

print(df[['int_col', 'int_col_num', 'float_col', 'float_col_num', 'mixed_numeric', 'mixed_numeric_num']].head())
print(df.dtypes)

print("\n2. Použití pd.to_datetime():")
# Konverze na datetime s různými formáty
df['date_std'] = pd.to_datetime(df['date_col'], errors='coerce')  # Automatická detekce formátu
df['date_fmt'] = pd.to_datetime(df['date_col'], format='%Y-%m-%d', errors='coerce')  # Konkrétní formát

print(df[['date_col', 'date_std', 'date_fmt']].head())
print(df.dtypes)

print("\n3. Použití pd.to_timedelta():")
# Konverze řetězců na časové intervaly
timedelta_data = ['1 days', '2 hours', '3 minutes', '4 seconds', '5 days 6 hours']
df['timedelta_col'] = timedelta_data
df['timedelta'] = pd.to_timedelta(df['timedelta_col'])

print(df[['timedelta_col', 'timedelta']].head())
print(df.dtypes)

print("\n4. Konverze na logické hodnoty:")
# Konverze různých forem logických dat
# True hodnoty: 'True', 'true', 't', 'yes', 'y', '1'
# False hodnoty: 'False', 'false', 'f', 'no', 'n', '0'
df['bool_std'] = df['bool_col'].str.lower().map({
    'true': True, 't': True, 'yes': True, 'y': True, '1': True,
    'false': False, 'f': False, 'no': False, 'n': False, '0': False
}).astype('boolean')

df['bool_custom'] = df['bool_col'].map(lambda x: x.lower() in ['true', 'yes', 'y', '1', 't'])

print(df[['bool_col', 'bool_std', 'bool_custom']].head())
print(df.dtypes)

print("\n5. Konverze na kategorický typ:")
# Konverze na kategorický typ
df['cat'] = df['categorical'].astype('category')
# S explicitním pořadím kategorií
df['cat_ordered'] = pd.Categorical(df['categorical'], 
                                   categories=['small', 'medium', 'large'], 
                                   ordered=True)

print(df[['categorical', 'cat', 'cat_ordered']].head())
print(f"Kategorie: {df['cat'].cat.categories}")
print(f"Seřazené kategorie: {df['cat_ordered'].cat.categories}")
print(f"Je seřazené: {df['cat_ordered'].cat.ordered}")
print(df.dtypes)
```

### 8.2 Efektivní konverze typů v DataFrame

```python
# Generování většího DataFrame pro demonstraci hromadných konverzí
import numpy as np
np.random.seed(42)
n_rows = 100000

large_df = pd.DataFrame({
    'id': range(n_rows),
    'int_col': np.random.randint(0, 100, size=n_rows),
    'float_col': np.random.rand(n_rows),
    'small_int': np.random.randint(0, 10, size=n_rows),
    'tiny_int': np.random.randint(0, 5, size=n_rows),
    'bool_col': np.random.choice([True, False], size=n_rows),
    'str_col': np.random.choice(['a', 'b', 'c', 'd', 'e'], size=n_rows),
    'date_col': pd.date_range('2000-01-01', periods=n_rows, freq='h')  # hodinově pro zamezení přetečení
})

# Kontrola počátečního využití paměti
print("Počáteční využití paměti DataFrame:")
print(large_df.info(memory_usage="deep"))
initial_memory = large_df.memory_usage(deep=True).sum()
print(f"Celkové využití paměti: {initial_memory / 1e6:.2f} MB")

# Konverze jednotlivých sloupců na efektivnější typy
print("\nOptimalizace využití paměti...")

# 1. Downcast celých čísel
large_df['int_col_opt'] = pd.to_numeric(large_df['int_col'], downcast='integer')
large_df['small_int_opt'] = pd.to_numeric(large_df['small_int'], downcast='integer')
large_df['tiny_int_opt'] = pd.to_numeric(large_df['tiny_int'], downcast='integer')

# 2. Downcast desetinných čísel
large_df['float_col_opt'] = pd.to_numeric(large_df['float_col'], downcast='float')

# 3. Konverze řetězců na kategorické
large_df['str_col_cat'] = large_df['str_col'].astype('category')

# Kontrola využití paměti po optimalizaci
print("\nVyužití paměti DataFrame po optimalizaci:")
print(large_df.info(memory_usage='deep'))
optimized_memory = large_df.memory_usage(deep=True).sum()
print(f"Celkové využití paměti: {optimized_memory / 1e6:.2f} MB")
print(f"Snížení paměti: {(1 - optimized_memory / initial_memory) * 100:.2f}%")

# Využití paměti pro jednotlivé sloupce
print("\nPorovnání využití paměti pro každý typ sloupce:")
for col in ['int_col', 'int_col_opt', 'small_int', 'small_int_opt', 
            'tiny_int', 'tiny_int_opt', 'float_col', 'float_col_opt', 
            'str_col', 'str_col_cat']:
    mem_usage = large_df[col].memory_usage(deep=True) / 1e6
    print(f"{col}: {mem_usage:.2f} MB, dtype: {large_df[col].dtype}")

# Funkce pro hromadnou konverzi
def optimize_dtypes(df):
    result = df.copy()
    
    # Optimalizace celých čísel
    int_cols = df.select_dtypes(include=['int64']).columns
    for col in int_cols:
        result[col] = pd.to_numeric(result[col], downcast='integer')
    
    # Optimalizace desetinných čísel
    float_cols = df.select_dtypes(include=['float64']).columns
    for col in float_cols:
        result[col] = pd.to_numeric(result[col], downcast='float')
    
    # Konverze řetězců s málo unikátními hodnotami na kategorické
    obj_cols = df.select_dtypes(include=['object']).columns
    for col in obj_cols:
        num_unique_values = len(df[col].unique())
        num_total_values = len(df[col])
        if num_unique_values / num_total_values < 0.5:  # Pokud je méně než 50% unikátních hodnot
            result[col] = result[col].astype('category')
    
    return result

# Vytvoření nové kopie původního DataFrame pro optimalizaci
df_original = large_df[['id', 'int_col', 'float_col', 'small_int', 'tiny_int', 'bool_col', 'str_col', 'date_col']]
df_optimized = optimize_dtypes(df_original)

# Porovnání využití paměti
original_mem = df_original.memory_usage(deep=True).sum() / 1e6
optimized_mem = df_optimized.memory_usage(deep=True).sum() / 1e6

print(f"\nVýsledky hromadné optimalizace:")
print(f"Původní paměť: {original_mem:.2f} MB")
print(f"Optimalizovaná paměť: {optimized_mem:.2f} MB")
print(f"Snížení paměti: {(1 - optimized_mem / original_mem) * 100:.2f}%")
print("\nOptimalizované dtypes:")
print(df_optimized.dtypes)
```

## 9. Využití paměti a efektivita

```python
# Porovnání využití paměti napříč různými datovými strukturami Pythonu
import sys

# Využití paměti primitivními typy Pythonu
print("Využití paměti primitivními typy Pythonu:")
print(f"int (0): {sys.getsizeof(0)} bajtů")
print(f"int (1000): {sys.getsizeof(1000)} bajtů")
print(f"int (10^20): {sys.getsizeof(10**20)} bajtů")  # Celá čísla v Pythonu mají libovolnou přesnost
print(f"float: {sys.getsizeof(0.0)} bajtů")
print(f"bool: {sys.getsizeof(True)} bajtů")
print(f"str (empty): {sys.getsizeof('')} bajtů")
print(f"str (10 znaků): {sys.getsizeof('a' * 10)} bajtů")
print(f"str (100 znaků): {sys.getsizeof('a' * 100)} bajtů")

# Využití paměti kontejnerů Pythonu
print("\nVyužití paměti prázdnými kontejnery:")
print(f"list: {sys.getsizeof([])} bajtů")
print(f"tuple: {sys.getsizeof(())} bajtů")
print(f"dict: {sys.getsizeof({})} bajtů")
print(f"set: {sys.getsizeof(set())} bajtů")

# Využití paměti kontejnery s prvky
print("\nVyužití paměti kontejnerů s prvky:")
print(f"list (10 int): {sys.getsizeof([0] * 10)} bajtů")
print(f"tuple (10 int): {sys.getsizeof((0,) * 10)} bajtů")
print(f"dict (10 položek): {sys.getsizeof({i: i for i in range(10)})} bajtů")
print(f"set (10 int): {sys.getsizeof(set(range(10)))} bajtů")

# Využití paměti polemi NumPy
print("\nVyužití paměti polemi NumPy:")
for dtype in [np.int8, np.int16, np.int32, np.int64, 
              np.float16, np.float32, np.float64]:
    arr = np.zeros(1000, dtype=dtype)
    print(f"1000 nul jako {dtype.__name__}: {arr.nbytes} bajtů")

# Využití paměti sériemi Pandas
print("\nVyužití paměti sérií Pandas (1000 prvků):")
for dtype in ['int8', 'int16', 'int32', 'int64', 
              'float32', 'float64', 'object', 'category']:
    if dtype == 'category':
        # Pro kategorický typ vytvořte data s málo unikátními hodnotami
        data = pd.Series(['A', 'B', 'C'] * 333 + ['D'])
        s = data.astype('category')
    elif dtype == 'object':
        # Pro objekty použijte řetězce
        s = pd.Series(['string'] * 1000)
    else:
        # Pro číselné typy použijte nuly
        s = pd.Series(np.zeros(1000, dtype=dtype))
    
    memory = s.memory_usage(deep=True)
    print(f"Série s dtype {s.dtype}: {memory} bajtů")

# Vizuální porovnání využití paměti
print("\nVizualizace využití paměti různými typy NumPy:")
dtypes = ['int8', 'int16', 'int32', 'int64', 'float16', 'float32', 'float64']
memory_usages = [np.zeros(1000, dtype=dtype).nbytes for dtype in dtypes]

plt.figure(figsize=(10, 6))
plt.bar(dtypes, memory_usages)
plt.title('Využití paměti 1000 nulami v polích NumPy')
plt.xlabel('Datový typ')
plt.ylabel('Využití paměti (bajty)')
plt.show()
```

### 9.1 Porovnání výkonu

```python
# Porovnání výkonu různých datových typů
import time

# Pomocná funkce pro měření času provádění
def measure_time(func, *args, **kwargs):
    start = time.time()
    result = func(*args, **kwargs)
    end = time.time()
    return result, end - start

# Vytvoření polí různých typů
size = 10_000_000
print(f"Vytváření polí s {size:,} prvky...")

# Pole NumPy s různými datovými typy
arrays = {
    'float64': np.random.random(size),
    'float32': np.random.random(size).astype(np.float32),
    'int64': np.random.randint(0, 100, size),
    'int32': np.random.randint(0, 100, size).astype(np.int32),
    'int16': np.random.randint(0, 100, size).astype(np.int16),
    'int8': np.random.randint(0, 100, size).astype(np.int8),
}

# Test výkonu pro sčítání
print("\nPorovnání výkonu pro sčítání pole:")
for name, arr in arrays.items():
    result, duration = measure_time(lambda: arr + arr)
    print(f"{name}: {duration:.6f} sekund")

# Test výkonu pro násobení
print("\nPorovnání výkonu pro násobení pole:")
for name, arr in arrays.items():
    result, duration = measure_time(lambda: arr * 2)
    print(f"{name}: {duration:.6f} sekund")

# Test výkonu pro matematické funkce
print("\nPorovnání výkonu pro trigonometrické operace:")
for name, arr in {k: v for k, v in arrays.items() if 'float' in k}.items():
    result, duration = measure_time(lambda: np.sin(arr))
    print(f"sin na {name}: {duration:.6f} sekund")

# Test výkonu pro porovnávací operace
print("\nPorovnání výkonu pro porovnávací operace:")
for name, arr in arrays.items():
    result, duration = measure_time(lambda: arr > arr.mean())
    print(f"{name}: {duration:.6f} sekund")

# Vytvoření DataFramů Pandas s různými datovými typy
print("\nVytváření DataFramů s různými datovými typy...")
df_size = 1_000_000
df_float64 = pd.DataFrame({'value': np.random.random(df_size)})
df_float32 = pd.DataFrame({'value': np.random.random(df_size).astype(np.float32)})
df_int64 = pd.DataFrame({'value': np.random.randint(0, 100, df_size)})
df_int32 = pd.DataFrame({'value': np.random.randint(0, 100, df_size).astype(np.int32)})
df_category = pd.DataFrame({'value': pd.Categorical(np.random.choice(['A', 'B', 'C', 'D', 'E'], df_size))})
df_object = pd.DataFrame({'value': np.random.choice(['A', 'B', 'C', 'D', 'E'], df_size)})

# Test výkonu pro filtrování v Pandas
print("\nPorovnání výkonu pro filtrování DataFrame:")
dataframes = {
    'float64': df_float64,
    'float32': df_float32,
    'int64': df_int64,
    'int32': df_int32,
    'category': df_category,
    'object': df_object
}

for name, df in dataframes.items():
    if name in ['category', 'object']:
        result, duration = measure_time(lambda: df[df['value'] == 'A'])
    else:
        result, duration = measure_time(lambda: df[df['value'] > 50])
    print(f"{name}: {duration:.6f} sekund")

# Test výkonu pro groupby operace v Pandas
print("\nPorovnání výkonu pro groupby v DataFrame:")
# Vytvoření DataFrame s 1M řádky a 10 skupinami
df_size = 1_000_000
groups = 10
df_int_group = pd.DataFrame({
    'group': np.random.randint(0, groups, df_size),
    'value': np.random.random(df_size)
})
df_obj_group = pd.DataFrame({
    'group': [f'G{i}' for i in np.random.randint(0, groups, df_size)],
    'value': np.random.random(df_size)
})
df_cat_group = df_obj_group.copy()
df_cat_group['group'] = df_cat_group['group'].astype('category')

groupby_dfs = {
    'int_group': df_int_group,
    'obj_group': df_obj_group,
    'cat_group': df_cat_group
}

for name, df in groupby_dfs.items():
    result, duration = measure_time(lambda: df.groupby('group', observed=False)['value'].mean())
    print(f"{name}: {duration:.6f} sekund")
```

## 10. Zpracování chyb datových typů

```python
# Běžné chyby při konverzi typů a strategie jejich zpracování

# 1. ValueError: Když hodnotu nelze převést na cílový typ
print("1. Zpracování ValueError při konverzi typů:")
strings_to_convert = ['123', '12.3', 'hello', '42x', '']

for s in strings_to_convert:
    # Jednoduchý přístup s try-except
    try:
        int_value = int(s)
        print(f"  Úspěšně převedeno '{s}' na int: {int_value}")
    except ValueError:
        print(f"  Nelze převést '{s}' na int")

print("\nKaskádové pokusy o konverzi:")
for s in strings_to_convert:
    try:
        # Nejprve zkusit int
        value = int(s)
        print(f"  '{s}' převedeno na int: {value}")
    except ValueError:
        try:
            # Pokud int selže, zkusit float
            value = float(s)
            print(f"  '{s}' převedeno na float: {value}")
        except ValueError:
            # Pokud obojí selže, ponechat jako řetězec
            print(f"  '{s}' ponecháno jako řetězec")

# 2. Overflow Error: Když je hodnota příliš velká pro cílový typ
print("\n2. Zpracování přetečení v konverzích NumPy:")
large_values = np.array([300, 500, 127, 128, 255, 256])
print(f"  Původní hodnoty: {large_values}")

# S ošetřením chyb
try:
    # Toto vyvolá chybu, pokud je varování převedeno na chybu
    with np.errstate(over='raise'):
        int8_values = large_values.astype(np.int8)
    print(f"  Převedeno na int8: {int8_values}")
except FloatingPointError:
    print("  Došlo k chybě přetečení během konverze")

# Bez ošetření chyb (NumPy ve výchozím nastavení zaokrouhlí)
int8_values = large_values.astype(np.int8)
print(f"  Převedeno na int8 (se zaokrouhlením): {int8_values}")

# Bezpečná konverze s ořezáním
print("\n  Bezpečná konverze s ořezáním:")
int8_min, int8_max = np.iinfo(np.int8).min, np.iinfo(np.int8).max
clipped_values = np.clip(large_values, int8_min, int8_max).astype(np.int8)
print(f"  Ořezáno do rozsahu int8: {clipped_values}")

# 3. Zpracování NA hodnot v Pandas
print("\n3. Zpracování NA hodnot v konverzích Pandas:")
df = pd.DataFrame({
    'A': ['1', '2', None, '4'],
    'B': ['1.1', '2.2', 'NaN', '4.4'],
    'C': ['2021-01-01', None, 'not-a-date', '2021-01-04']
})
print(df)

print("\nPoužití pd.to_numeric s errors='coerce':")
df['A_int'] = pd.to_numeric(df['A'], errors='coerce')
df['B_float'] = pd.to_numeric(df['B'], errors='coerce')
print(df)

print("\nPoužití pd.to_datetime s errors='coerce':")
df['C_date'] = pd.to_datetime(df['C'], errors='coerce')
print(df)

# 4. Vlastní konverzní funkce s validací
print("\n4. Vlastní konverzní funkce s validací:")

def safe_convert(value, target_type, default=None):
    """Bezpečně převede hodnotu na target_type, v případě selhání vrátí default."""
    try:
        if target_type == int:
            # Pro int zkusit nejprve float pro zpracování případů '3.0'
            return int(float(value)) if value is not None and value != '' else default
        elif target_type == float:
            return float(value) if value is not None and value != '' else default
        elif target_type == bool:
            if isinstance(value, str):
                return value.lower() in ('true', 'yes', 'y', '1', 't') if value else default
            return bool(value) if value is not None else default
        elif target_type == pd.Timestamp:
            return pd.to_datetime(value) if value is not None and value != '' else default
        else:
            return target_type(value) if value is not None and value != '' else default
    except (ValueError, TypeError):
        return default

# Otestování funkce safe_convert
test_values = [
    '123', '456.7', 'True', 'yes', 'no', 'false',
    '2021-01-01', '01/01/2021', 'not-a-date', None, ''
]

print("Testování funkce bezpečné konverze:")
for value in test_values:
    print(f"  Hodnota: '{value}'")
    print(f"    Na int: {safe_convert(value, int, default='NEPLATNÉ')}")
    print(f"    Na float: {safe_convert(value, float, default='NEPLATNÉ')}")
    print(f"    Na bool: {safe_convert(value, bool, default='NEPLATNÉ')}")
    print(f"    Na datetime: {safe_convert(value, pd.Timestamp, default='NEPLATNÉ')}")

# 5. Aplikace vlastní konverze na DataFrame
print("\n5. Aplikace bezpečné konverze na DataFrame:")
messy_data = {
    'id': ['1', '2', '3', '4', '5'],
    'value': ['10', '20.5', 'thirty', '40', None],
    'ratio': ['0.5', '60%', '0.75', '90%', 'unknown'],
    'flag': ['1', 'yes', 'false', 'no', None],
    'date': ['2021-01-01', '01/15/2021', '2021-03-01', 'invalid', '']
}

messy_df = pd.DataFrame(messy_data)
print("Původní neupravený DataFrame:")
print(messy_df)

# Aplikace bezpečných konverzí
print("\nPo bezpečných konverzích:")
cleaned_df = messy_df.copy()
cleaned_df['id'] = messy_df['id'].apply(lambda x: safe_convert(x, int))
cleaned_df['value'] = messy_df['value'].apply(lambda x: safe_convert(x, float))

# Vlastní zpracování pro procenta
def parse_percentage(x):
    if isinstance(x, str) and '%' in x:
        return float(x.replace('%', '')) / 100
    return safe_convert(x, float)

cleaned_df['ratio'] = messy_df['ratio'].apply(parse_percentage)
cleaned_df['flag'] = messy_df['flag'].apply(lambda x: safe_convert(x, bool))
cleaned_df['date'] = pd.to_datetime(messy_df['date'], errors='coerce')

print(cleaned_df)
print(cleaned_df.dtypes)
```

---

# Datové typy a konverze v datové vědě

## Hlavní body a témata

### 1. Základní datové typy v Pythonu
- Numerické typy: `int`, `float`
- Booleovský typ: `bool` 
- Řetězce: `str`
- Kontejnerové typy: `list`, `tuple`, `dict`, `set`

### 2. Datové typy v NumPy
- Efektivnější datové typy pro vědecké výpočty
- Různé velikosti typů: `int8`, `int32`, `int64`, `float32`, `float64`
- Speciální typy: komplexní čísla, datum a čas, strukturované pole

### 3. Datové typy v Pandas
- Rozšířené typy pro práci s tabulkovými daty
- Kategorické typy pro efektivní práci s opakovanými hodnotami
- Nullable typy pro konzistentní zpracování chybějících hodnot
- Typy pro práci s datem a časem

### 4. Kontrola a identifikace typů
- Vestavěné funkce Pythonu: `type()`, `isinstance()`
- Funkce v NumPy: `dtype`, `issubdtype()`
- Metody v Pandas: `dtypes`, `pd.api.types`

### 5. Konverze typů v Pythonu
- Explicitní konverze mezi typy
- Implicitní konverze (typová koerce)
- Převody mezi kontejnerovými typy

### 6. Konverze typů v NumPy
- Použití `astype()` pro změnu typu pole
- Problematika přetečení a ztráty přesnosti
- Specializované konverzní funkce

### 7. Konverze typů v Pandas
- Funkce `pd.to_numeric()`, `pd.to_datetime()`, `pd.to_timedelta()`
- Konverze na kategorický typ
- Efektivní hromadné konverze pro optimalizaci paměti

### 8. Paměťová náročnost a efektivita
- Porovnání paměťových nároků různých datových typů
- Vliv datových typů na výpočetní výkon
- Optimalizace typů pro velké datasety

### 9. Zpracování chyb datových typů
- Běžné chyby při konverzi typů
- Strategie pro ošetření chyb
- Vytváření bezpečných konverzních funkcí

### 10. Zpracování chyb datových typů
- **Typické chyby při konverzi**: ValueError, OverflowError
- **Strategie ošetření chyb**:
  - Použití `try-except` bloků pro zachycení chyb
  - Kaskádové pokusy o konverzi (zkusit nejdříve int, pak float)
  - Oříznutí hodnot pomocí `np.clip()` pro řešení přetečení
  - Použití `pd.to_numeric()` a `pd.to_datetime()` s parametrem `errors='coerce'` pro převod neplatných hodnot na NaN
- **Vlastní bezpečné konverzní funkce**:
  - Implementace validační logiky
  - Poskytnutí výchozích hodnot pro neplatné vstupy
  - Speciální zpracování pro různé formáty (např. procenta, datumy)
- **Aplikace na DataFrame**:
  - Systematická konverze sloupců s nekonzistentními daty
  - Zachování původních dat s vytvořením nových sloupců pro konvertované hodnoty

## Shrnutí 1

Notebook poskytuje komplexní přehled datových typů a technik konverze v Pythonu, NumPy a Pandas, které jsou zásadní pro efektivní práci s daty. Správné porozumění a používání datových typů má významný dopad na paměťovou efektivitu, výpočetní výkon a robustnost datových analýz. Zvláštní pozornost je věnována optimalizaci typů pro velké datasety a správnému zpracování chyb při konverzi, což je nezbytné při práci s reálnými daty, která často obsahují nekonzistence nebo neočekávané hodnoty. Volba vhodných datových typů a implementace robustních konverzních strategií jsou základními dovednostmi každého datového analytika nebo vědce.

## Shrnutí 2

Notebook poskytuje komplexní přehled datových typů a technik konverze v Pythonu, NumPy a Pandas. Správné porozumění datovým typům je klíčové pro efektivní práci s daty, optimalizaci paměťových nároků a výpočetního výkonu. Zvláště důležité je zpracování chyb při konverzi typů, protože reálná data často obsahují nekonzistence, neplatné hodnoty nebo formáty neodpovídající očekávanému typu.

Kapitola o zpracování chyb datových typů detailně popisuje různé strategie, jak se vypořádat s běžnými problémy při konverzi: od základního zachycení výjimek přes kaskádové pokusy o konverzi až po sofistikované vlastní konverzní funkce s validací. Důležitou součástí je také práce s přetečením hodnot v NumPy a zpracování chybějících hodnot v Pandas pomocí parametru `errors='coerce'`.

Implementace bezpečných konverzních funkcí je nezbytným nástrojem každého datového analytika nebo vědce, protože umožňuje systematický přístup ke zpracování nekonzistentních dat a minimalizaci chyb v analytickém procesu. Ukázaná vlastní funkce `safe_convert` demonstruje komplexní řešení, které pokrývá většinu běžných scénářů konverze typů a poskytuje robustní základ pro zpracování reálných datasetů.